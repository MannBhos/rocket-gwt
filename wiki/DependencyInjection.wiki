#labels Featured,DependencyInjection,Spring,GWT,Advices,Aop,MethodInterceptors,CodeGeneration
=Purpose=

The purpose of the rocket.beans package is to offer the ability to DI beans and add advices within a GWT application.
Many but not all of the DI and aop concepts made popular by Spring and other DI packages are supported. This page does not attempt to explain all the pros and cons of using DI. It rather concentrates on using the rocket beans implementation.

=Differences with Spring DI=

All resolution occurs during the code generation step and not at runtime. Spring and other DI frameworks take advantage of java runtimes such as reflection and classloading which are not available within a GWT environment.

=Whats supported and works=
Many of the popular DI/AOP concepts developers are familiar present with some restrictions due to the browser environment. 

Many of the copied ideas use the same interfaces/names when possible but live under the rocket.beans package.
  * Singletons - One instance exists throughout the BeanFactory
  * Prototypes - A new instance is created each time the BF is queried.
  * Method advices are achieved via generated proxies with advices/interceptors weaved into the proxy.
  * FactoryBean - Any bean defined which implements rocket.beans.client.FactoryBean is not returned but rather asked to produce a bean itself.
  * InitializingBean - any bean implementing rocket.beans.client.InitializingBean has its afterPropertiesSet() method invoked after all properties are set but before the bean leaves the factory.
  * Several types of advices are supported, all relating to methods only. Before, after returning, after throwing, after finally and method interceptors. The method signatures and when these advices are called are very similar to those found in Spring.

=What doesnt work=
  * The destroy lifecycle event is not support. Work is continuing on the best strategy to implement this. The most likely mechanism to implement this portion of a beans lifecycle is via listener registered to com.google.gwt.user.client.WindowCloseListener.onWindowClosing
  * Autowiring to satisfy all properties of a bean.
  * The ability to load beans eagerly or lazily is not supported. All references and values are verified during the compilation, with instances created lazily.
  * Fields advices are not supported.

=Getting started=

The following steps below list what and how to use this feature in your own development efforts. The first part describes how to edit the xml file, with the second describing the  programmatic effort required to get a BeanFactory and fetch a bean.

==Importing the rocket module==

Add the rocket module to your own module.

{{{
<module name="Rocket.User" />
}}}

==Defining a bean factory==

Create a new interface that extends rocket.beans.client.BeanFactory. It must not contain any methods.

{{{
package example;

rocket.beans.client.BeanFactory

public ExampleBeanFactory extends BeanFactory{
	// with no methods!
}
}}}

==Creating the xml config file which defines all beans==

The last step involves defining beans, dependencies and advices using the xml file. The xml file format is explained below. A file must appear in the same package or directory as the interface implementing rocket.bean.client.BeanFactory.

eg: For a class called sample.SampleBeanFactory an xml file called SampleBeanFactory.xml  must also appear in the sample package directory.

A dtd may be found in rockket.bean.rebind.xml.Beans.dtd. THis dtd is also used to validate the xml file. Various structural errors are caught by the parser before the beans generator can read the xml document.

==Defining a Bean==
Any concrete class may be given an id and defined as a bean using the <bean> tag.
The bean tag includes a number of attributes
  * id - A unique id of the bean.
  * class - The fully qualified class name of the bean type. The class must be a concrete class otherwise the code generator will complain.
  * scope - This attribute may contain either singleton or prototype.
  * factoryMethod - When present specifies a static method on the defined class that can be used to retrieve a new instance of the bean.
  * initMethod - When present this method (which must be a public instance method) will invoked after all properties are set but before the bean leaves the factory. This may be used in preference to rocket.beans.client.InitializingBean.

The sample below defines a singleton bean with an id of "rocketBean".
{{{
<bean
   id="rocketBean"
   class="sample.RocketBean"
   scope="singleton" >
}}}

The above fragment would be equivalent to the following code. The RocketBean class must have a constructor that takes a String in this example.

{{{
  sample.RocketBean rocketBean = new sample.RocketBean( "Go!" );
}}}

===Constructor===
By default all beans must have a public default / no arguments constructor. If such a constructor is not present in the bean type, the bean may be created by a constructor that satisfies the child values.

{{{
<bean
   id="rocketBean"
   class="sample.RocketBean"
   scope="singleton" >

   <constructor>
     <value>Go!</value>
   </constructor>
}}}

If more than one constructor can match the constructor values, the generator will report a failure. Given the sample.AmbiguousConstructorRocketBean contains the following constructors, one that takes a byte and another that takes a int. The value tag content of "1" can be matched to both constructors. In this case the code generation step fails. Values are described under the values heading.

{{{
<bean
   id="ambiguousConstructor"
   class="sample.AmbiguousConstructorRocketBean"
   scope="singleton" >

   <constructor>
     <value>1</value>
   </constructor>

}}}

==Properties==
Properties may also be set via the <properties> tag. Each <properties> tag may in turn contain one or more <property> tags each setting a single value upon the bean.

Each property must have a public setter method that accepts a single value and returns void. A variety of property types may be set including all the primitive types, java.lang.String, java.util.List, java.util.Set, java.util.Map and other beans.

===Property===
The property tag below may be used to set a property called foo with a value of bar.
{{{
...
<property name="foo">
  <value>bar</value>
</property>
...
}}}

Skipping the creation of the instance the above is equivalent to
{{{
  instance.setFoo( "bar" );
}}}

==Values==
Several tags are available that allow several types of constructor arguments and properties. These include
  * Primitive types Any boolean, byte, short, int, long, float, double, char value.
  * String any string value
  * List A list of other values.
  * Set A set of other values.
  * Map A map containing string keys and Value values.
  * Beans reference - Any other bean that is defined within the xml document.

===Value===
{{{
<value>123</value>
}}}
Within a <property> tag the above could set a value of 123 upon a byte, short, int, long, float or double property.

===list===
The above <list> tag creates a list with 3 String elements containing "Foo", "Bar", and "Baz". Any values type may appear within a list
{{{
<list>
  <value>Foo</value>
  <value>Bar</value>
  <value>Baz</value>
</list>
}}}

Within a <property name="list"> tag this is equivalent to
{{{
java.util.List list = new java.util.ArrayList();
list.add( "Foo" );
list.add( "Bar" );
list.add( "Baz" );
instance.setList( list );
}}}

===set===
The set tag is also identical but can be used as a constructor parameter or property with a java.util.Set type. Any values type may appear within a set.

===map===
The map tag may be used to populate a constructor parameter or property with a java.util.Map type. The xml fragment below creates a map with 1 entry with a string value.
{{{
<map>
  <map-entry key="foo">
   <value>bar</value>
  </map>
</map>
}}}

The xml above is equivalent to the following code fragment assuming it appeared within a <property name="map"> tag.
{{{
  java.util.Map map = new java.util.Map();
  map.put( "foo", "bar" );
  instance.setMap( map );
}}}

===bean reference===
The <bean-reference> tag may be used to pass a bean to a constructor or set a property with a defined bean.
{{{
<bean-reference id="anotherBean" />
}}}

===remote rpc service===
The <remote-rpc-service> may be used as a convenience to fetching a rpc service proxy.
Remote rpc service's are just ordinary beans and may be referenced by any other bean definition via the <bean-reference> tag.
{{{
<remote-rpc-service
  address="url"
  id="rpc"
  interface="sample.RemoteRpcService"
}}}
The above code fragment exposes a bean which may be fetched from the bean factory using the following code. It also possible to set a property or constructor with the same bean using the <property> or <constructor> tags.
{{{
  sample.RemoteRpcServiceAsync rpc = (sample.RemoteRpcServiceAsync) beanFactory.getBean("rpc");
}}}

The xml fragment is equivalent to the following
{{{
  sample.RemoteRpcServiceAsync rpc = (sample.RemoteRpcServiceAsync} GWT.create( sample.RemoteRpcService.class);   
  ((ServiceDefTarget)sample).setServiceEntryPoint("url");
}}}

===remote json service===
The <remote-json-service> tag is identical to the <remote-rpc-service> tag but create s a remote json service proxy instead.

===advice===
The <advice> tag may be used to declare an advice to one or more methods upon a target bean. Beans may have more than one advice. If a different advisor is needed a new advisor tag must be included. The advice below advices all public methods that starting with "set" calling the advisorBean before invoking the target setXXX method.
{{{
<advice
  advisorBeanId="advisorBean"
  targetBeanId="bean"
  methodExpression="set * "
/>
}}}

The advisor bean above must be an advice or some sort, implementing any of the following interfaces.
  * rocket.beans.client.aop.AfterFinallyAdvice - An after finally advice is called after a method returns.
  * rocket.beans.client.aop.AfterReturningAdvice - A after returning advice is called and presented with the returned value of the target method or advice.
  * rocket.beans.client.aop.AfterThrowingAdvice - Receives any exception that is thrown by an advice or the target.
  * rocket.beans.client.aop.BeforeAdvice - Is invoked before the target method.
  * rocket.beans.client.aop.MethodInterceptor - The most versatile form of applying an advice.

=Troubleshooting=
Messages are logged at different levels during key portions bean factory generation. In order to view these the LOGLEVEL option must be set with INFO producing medium levels of messages and DEBUG resulting in many more. All problems are caught and logged.

=More Info, Tests, Examples=
A number of tests are available that test each and every of the features described above.
Typically each test method includes a sub package which contains the actual BeanFactory interface and xml file along with any supporting types.
  * *rocket.beans.test.beans.client.BeansGwtTestCase

The tests below are regular junit tests that test many of the templated abstract classes used during code generation or at runtime.
  * `rocket.beans.test.AfterFinallyAdviceMethodInterceptorTestCase`
  * `rocket.beans.test.AfterReturningAdviceMethodInterceptorTestCase`
  * `rocket.beans.test.AfterThrowingAdviceMethodInterceptorTestCase`
  * `rocket.beans.test.BeanFactoryTestCase`
  * `rocket.beans.test.BeforeAdviceMethodInterceptorTestCase`
  * `rocket.beans.test.InterceptorChainTestCase`
  * `rocket.beans.test.MethodMatcherTestCase`
  * `rocket.beans.rebind.aop.MethodMatcher`
  * `rocket.beans.test.PlaceHolderResolverTestCase`
  * `rocket.beans.test.PrototypeFactoryBeanTestCase`
  * `rocket.beans.test.ProxyFactoryBeanTestCase`
  * `rocket.beans.test.SingletonFactoryBeanTestCase`

The entire beans package uses the Rocket generator package to generate the BeanFactory, FactoryBeans, and proxies.