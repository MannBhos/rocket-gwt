<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Json Deserialization</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>

<body>
<h1>Purpose</h1>
<p>
The rocket.json package includes a simple provision to map java objects to a json encoded stream. This makes it easy to build a java object
from json without any manual binding.
</p>

<p>
The library supports the following mappings from json to java.
</p>
<ul>
<li>Json objects become java objects or <code>java.util.Map</code></li>
<li>Json arrays become <code>java.util.List</code> or <code>java.util.Set</code></li>
<li>Json numbers become any of the numeric primitives <code>byte, short, int, long, float, or double</code>.</li>
<li>Json Strings become <code>java.lang.String</code> or chars(which are actually useless but included for completeness)</li>
<li>Json booleans become <code>booleans</code>
</ul>

<h1>Requirements</h1>
<h2>Class and JsonSerializable</h2>
<p>
Following in java / gwt tradition a marker interface must be implemented by classes that wish to be serializable. In the case
of the rocket library this is <code>rocket.json.client.JsonSerializable</code>.
</p>

<div class="info">
By design the <code>java.io.Serializable</code> and <code>com.google.gwt.user.client.rpc.IsSerializable</code> are already mapped to a different Generator which produces (de)serializers for the GWT rpc subsystem.
</div>


<h2>Fields annotations.</h2>
<p>
The <code>rocket json</code> package needs some help in mapping a json stream into a java object.
Only non transient, instance fields will be serializable. The visibilty of the field does not affect its ability to be (de)serialized.


<div class="info">
The generator (<code>rocket.json.rebind.JsonSerializerGenerator</code>) uses JSNI to set each of the individual fields belonging to the instance being built. Field access visibility rules are not
enforced within JSNI code.
</div>

<h3>Json objects</h3>
Each json object which is ultimately made up of key/value pairs maps to a single java type. Each field belonging to the type must use annotations to say what key will be used to populate it.
<pre>

/**
* Something about the foo field..
* Maps a value referened by the "bar" key to the foo field for the enclosed class.
*
* @javascriptPropertyName bar
*/
private String foo;
</pre>

<h3>Json array</h3>
<p>
An annotation must be included to tell the system the type of each element of the list or set.
</p>

<pre>
/**
* Something about the foo field..
*
* The elements of the foo json array will be interpretted as Strings.
*
* @listElementType &lt;java.lang.String&gt;
*/
private String foo;
</pre>

<h1>Getting started with a quick simple example...</h1>
<p>
The following steps below list what and why is needed to use this facility in your own development efforts.
</p>

<h2>Importing the rocket module</h2>
<p>
Add the rocket module to your own module.
</p>
<pre>
&lt;module name="Rocket.User" /&gt;
</pre>

<h2>Json</h2>
<p>
The sample below includes a simple json object graph which includes all json types. It will be used as the basis for the contrived
Java classes created below.
</p>
<pre>
	{
		"foo":	true;           <b>// json boolean.</b>
		"bar":  123;  	        <b>// json number</b>
		"array": [ 1, 2, 3 ];	<b>// json array </b>
		"object" {
		   "baz":  "apple"; 	<b>// json string</b>
		}
	}
</pre>

<h2>Binding classes</h2>
<p>
Two separate classes are required, one for each json object present in the convulted example given above.
The outter object includes 4 properties.
<ul>
<li>foo</li>
<li>bar</li>
<li>array</li>
<li>object</li>
</ul>

<p>
The code snippet below includes all the fields and required annotations that would be required to map the outter object to a class called
OutterClass.
</p>

<pre>
package somepackage;
import rocket.json.client.JsonSerializable;

public class OutterClass implements JsonSerializable{
	/**
	* @javascriptPropertyName foo
	*/
	private boolean foo;
	/**
	* @javascriptPropertyName bar
	*/
	private int number;
	/**
	* @javascriptPropertyName array
	* @listElementType &lt;java.lang.Integer&gt;
	*/
	private java.util.List number;
	/**
	* @javascriptPropertyName object
	*/
	private InnerClass innerClass;
}
</pre>

<p>
The inner object includes 1 property.
<ul>
<li>baz</li>
</ul>

<p>
The code snippet below includes all the fields and required annotations that would be required to map the inner object to a class called InnerClass.
</p>

<pre>
package somepackage;
import rocket.json.client.JsonSerializable;

public class InnerClass implements JsonSerializable{
	/**
	* @javascriptPropertyName baz
	*/
	private String baz;
}
</pre>

<h2>Application code</h2>
<p>
Include required import statements.
</p>
<pre>
import rocket.json.client.JsonSerializer;
</pre>

<p>
To de serialize a json object to java a reference to a JsonSerializer must obtained using deferred binding.
</p>
<pre>
JSONObject jsonObject = <b>// already got it from somewhere...</b>
JsonSerializer deserialize = (JsonSerialize) GWT.create( SomeClass.class );
</pre>

<p>
Then proceed to ask the deserializer to build a java object from the given json object.
A <code>rocket.json.client.JsonDeserializationException</code> will be thrown if anything goes wrong. Its not checked which adds flexibility.
</p>
<pre>
SomeClass instance = (SomeClass) deserialize.asObject( jsonObject );
</pre>

<h1>Further samples</h1>
<p>
For further examples refer to the unit test <code>rocket.json.test.client.JsonGwtTestCase</code>
</p>

</body>